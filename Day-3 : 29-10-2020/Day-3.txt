							DAY -3 : 29-10-2020
	
____________________________________________________________________________________________________________________________________________________________________
		Device Tree Binary File (DTB)
		
Flatterned Device Tree (Platform Devices):

The peripherals which are unable to announces their existence to OS is known as Platform Devices

One way is to write static library file while booting up and let peripheral devices announces their existence so that it is recognized.
Even this draw back : size of linux kernel increases due to more number of libraries

( NOTE: Compiler converts .c to hex files and maps to memory
 	
)

Solution for above drawback:
	ARM community came with a solution of Device Tress Source file(.c files)
	DTS file are uImages
	DTS file are hardcoded hardwar details in to linux kernel
	DTS file consists of configuration of all kind of peripherals
	DTS file are simple c file not binary files
	DTS file are not final executable file but these are executable bcoz the community has designed in built compiler.
	These are not taking any compiler space
	
	dtc file(it is also another .c file) equivalent to compiler file converts DTS into DTB and memory is allocated as it is now binary file
	It is done during run time based on the board selected (appropriate DTS file will be selected from ROOTFS folder) and converts into DTB 
	
	DTS file is stored in ROOTFS
	
	
	
How does board is getting identified:
	Kernel just looks for DTB address and loads the file
	
	
____________________________________________________________________________________________________________________________________________________________________


Step 1: Enter into U-Boot Area
Step 2: 
	How to create your own custom environmental variable
	
	bootm boot [adrs..[arg]] - boot from memory
	load <interface> [dev:<part>]
	printenv - prints environment variable
	
	printenv sesrverip
	setenv myserverip 'serverip' (my own env)
	printenv myserverip
	
	Env variable can only be set or changed
	
	run will exectue command not env
	load will only run the command
	
	mmc list (is command)
	setenv mymmclist 'mmc list'
	printenv mymmclist
	
	run mymmclist  (executed)
	
	we can set the custom env variables to run the predefined commands
	

Step 3:
	load mmc 0:2 0x82000000 /boot/uImage
	8645240 bytes read in 559 ms (14.7 MiB/s)
	
	load mmc 0:2 0x88000000 /boot/am335x-boneblack.dtb
	56827 bytes read in 20ms (2.7 MiB/s)
	
	
	(booting from memory)
	bootm 0x82000000 - 0x88000000 (Providing the range of memory to execute Enter)
	Starting kernel ....
	It doesnt Boot and no logs have been printed
	
	(to see logs use bootargs)
	
	printenv bootargs
		Error: bootargs Not defined
	setenv bootagrs console=ttyO0,115200 (Name of usb , bod rate)
	
	Now
	
	load mmc 0:2 0x82000000 /boot/uImage
	load mmc 0:2 0x88000000 /boot/am335x-boneblack.dtb
	setenv bootagrs console=ttyO0,115200 root=/dev/mmcblk0p2 rw
	bootm 0x82000000 - 0x88000000
	
	Kernel Loads
	
____________________________________________________________________________________

Keep the uEnv.txt file in host machine and read from the host machine


	Always one line need to be extra in uEnv.txt
	setenv serverip = 192.168.1.1
	loady
	ctrl+A S
	  Select ymodem
	  double space to edit
	  go to file path uEnv.txt
	  space enter
	  
	  printenv serverip
	  
	  
	  env import -t 0x82000000 29
	  boot is the commannd which executes bootcmd

______________________________________________________________________________________________________________________________________________________________
			Linux boot sequence discussion-Boot strap loader
			

	u_boot calls jump to kernel funvtion
	it accepts one structure parameter and flag
	 this struture has an element (ep - entry point of os)
	 this ep gives the ft_address of DTB file and stores it in r2(register)
	 
	 and passes to kernel_entry(0,r1,r2)
	r1- machine id of the board 





